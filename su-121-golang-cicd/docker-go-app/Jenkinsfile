#!/usr/bin/env groovy
def ARTDOCKER_REGISTRY = "jfrog.local:5000"
def REPO = "docker-virtual"
def PROMOTE_REPO = "docker-prod-local"
def SOURCE_REPO = "docker-stage-local"
def SERVER_URL = "http://jfrog.local/artifactory"

node {

    def rtServer = Artifactory.newServer url: SERVER_URL, credentialsId: CREDENTIALS
    def rtDocker = Artifactory.docker server: rtServer
    def buildInfo = Artifactory.newBuildInfo()
    def tagName
    buildInfo.env.capture = true
    def lastAppBuild = getLatestAppBuild(SERVER_URL)

    stage ('Clone') {
        cleanWs()

        git url: 'https://github.com/jfrogtraining/swampup2019', branch : 'gophercon'

    }

    //Fetch all dependencies from Artifactory
    stage('Dependencies') {
        dir('su-121-golang-cicd/docker-go-app') {
            def downloadSpec = """{
                     "files": [
                      {
                       "pattern": "go-binaries/jfrog/go-swampup-service/go-swampup-service-linux-x86-1.2.${lastAppBuild}.bin",
                       "target": "go-swampup-service",
                       "flat":"true"                       
                      }
                      ]
                    }"""
            sh "jfrog rt dl --flat=true --build-name=${env.JOB_NAME} --build-number=${env.BUILD_NUMBER} go-binaries/jfrog/go-swampup-service/go-swampup-service-linux-x86-1.2.${lastAppBuild}.bin ./go-swampup-service"
            rtServer.download (downloadSpec, buildInfo)
            if (fileExists('go-swampup-service')) {
                println "Downloaded dependencies"
            } else {
                println "Missing Dependencies"
                throw new FileNotFoundException("Missing Dependencies")
            }
        }
    }

    stage ('Build source and Image') {
        dir('su-121-golang-cicd/docker-go-app') {
            tagName = "${ARTDOCKER_REGISTRY}/docker-go-app:${env.BUILD_NUMBER}"
            docker.build(tagName)
            buildInfo = rtDocker.push(tagName, "docker-virtual", buildInfo)
            rtServer.publishBuildInfo buildInfo
        }
    }

    stage ('Test') {
        dir('su-121-golang-cicd/docker-go-app') {
            //ToDo
        }
    }

    stage('Xray Scan') {
        if (XRAY_SCAN == "YES") {
            def xrayConfig = [
                'buildName'     : env.JOB_NAME,
                'buildNumber'   : env.BUILD_NUMBER,
                'failBuild'     : false
            ]
            def xrayResults = rtServer.xrayScan xrayConfig
            sleep 60
            echo xrayResults as String
        } else {
            println "No Xray scan performed. To enable set XRAY_SCAN = YES"
        }

    }

    stage ('Promote') {
        dir('su-121-golang-cicd/docker-go-app') {
            def promotionConfig = [
              'buildName'          : env.JOB_NAME,
              'buildNumber'        : env.BUILD_NUMBER,
              'targetRepo'         : "docker-prod-local",
              'comment'            : 'Go-App test with latest version of application',
              'sourceRepo'         : "docker-stage-local",
              'status'             : 'Released',
              'includeDependencies': false,
              'copy'               : true
            ]
            rtServer.promote promotionConfig
            reTagLatest (SOURCE_REPO)
            reTagLatest (PROMOTE_REPO)
        }

    }
}

def updateDockerFile () {
    def BUILD_NUMBER = env.BUILD_NUMBER
    sh "sed -i 's/docker.artifactory/${ARTDOCKER_REGISTRY}/' Dockerfile"
    sh 'sed -i "s/go-app:latest/go-app:$BUILD_NUMBER/" Dockerfile'
}

def reTagLatest (targetRepo) {
     def BUILD_NUMBER = env.BUILD_NUMBER
     sh 'sed -E "s/@/$BUILD_NUMBER/" retag.json > retag_out.json'
     switch (targetRepo) {
          case "docker-prod-local" :
              sh 'sed -E "s/TARGETREPO/docker-prod-local/" retag_out.json > retaga_out.json'
              break
          case "docker-stage-local" :
               sh 'sed -E "s/TARGETREPO/docker-stage-local/" retag_out.json > retaga_out.json'
               break
      }
      sh 'cat retaga_out.json'
      withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: CREDENTIALS, usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD']]) {
          def curlString = "curl -u " + env.USERNAME + ":" + env.PASSWORD + " http://jfrog.local/artifactory"
          def regTagStr = curlString +  "/api/docker/docker-stage-local/v2/promote -X POST -H 'Content-Type: application/json' -T retaga_out.json"
          println "Curl String is " + regTagStr
          sh regTagStr
      }
}

def getLatestAppBuild (server_url) {

   def aqlString = 'builds.find ({"name": {"$eq":"step1-go-app"}}).sort({"$desc":["created"]}).limit(1)'

   File aqlFile = File.createTempFile("buildlatest", ".tmp")
   aqlFile.deleteOnExit()

   aqlFile << aqlString

   withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: CREDENTIALS, usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD']]) {
       def getLatestBuild = "curl -u$USERNAME:$PASSWORD -X POST " + server_url + "/api/search/aql -T " + aqlFile.getAbsolutePath()

       try {
             def buildInfo = getLatestBuild.execute().text
             def jsonSlurper = new JsonSlurper()
             def latestBuild = jsonSlurper.parseText("${buildInfo}")

             return latestBuild ? latestBuild.results[0]."build.number":"latest"
        } catch (Exception e) {
            println "Caught exception finding latest app build. Message ${e.message}"
            throw e
        }
    }
}
